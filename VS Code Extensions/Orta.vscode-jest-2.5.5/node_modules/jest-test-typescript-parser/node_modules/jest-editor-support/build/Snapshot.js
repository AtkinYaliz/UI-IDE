/**
 * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

'use strict';Object.defineProperty(exports, "__esModule", { value: true });var _babelTraverse;

function _load_babelTraverse() {return _babelTraverse = _interopRequireDefault(require('babel-traverse'));}var _babylon_parser;
function _load_babylon_parser() {return _babylon_parser = require('./parsers/babylon_parser');}var _jestSnapshot;
function _load_jestSnapshot() {return _jestSnapshot = require('jest-snapshot');}function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };}










const describeVariants = Object.assign(
Object.create(null),
{
  describe: true,
  fdescribe: true,
  xdescribe: true });


const base = Object.assign(Object.create(null), {
  describe: true,
  it: true,
  test: true });

const decorators = Object.assign(Object.create(null), {
  only: true,
  skip: true });


const validParents = Object.assign(
Object.create(null),
base,
describeVariants,
Object.assign(Object.create(null), {
  fit: true,
  xit: true,
  xtest: true }));



const isValidMemberExpression = node =>
node.object &&
base[node.object.name] &&
node.property &&
decorators[node.property.name];

const isDescribe = node =>
describeVariants[node.name] ||
isValidMemberExpression(node) && node.object.name === 'describe';

const isValidParent = parent =>
parent.callee && (
validParents[parent.callee.name] || isValidMemberExpression(parent.callee));

const getArrayOfParents = path => {
  const result = [];
  let parent = path.parentPath;
  while (parent) {
    result.unshift(parent.node);
    parent = parent.parentPath;
  }
  return result;
};

const buildName =



(snapshotNode, parents, position) => {
  const fullName = parents.map(parent => parent.arguments[0].value).join(' ');

  let describeLess = '';
  if (!isDescribe(parents[0].callee)) {
    // If `it` or `test` exists without a surrounding `describe`
    // then `test ` is prepended to the snapshot fullName.
    describeLess = 'test ';
  }

  return (_jestSnapshot || _load_jestSnapshot()).utils.testNameToKey(describeLess + fullName, position);
};

class Snapshot {


  constructor(parser, customMatchers) {
    this._parser = parser || (_babylon_parser || _load_babylon_parser()).getASTfor;
    this._matchers = ['toMatchSnapshot', 'toThrowErrorMatchingSnapshot'].concat(
    customMatchers || []);

  }

  getMetadata(filePath) {
    const fileNode = this._parser(filePath);
    const state = {
      found: [] };

    const Visitors = {
      Identifier(path, state, matchers) {
        if (matchers.includes(path.node.name)) {
          state.found.push({
            node: path.node,
            parents: getArrayOfParents(path) });

        }
      } };


    (0, (_babelTraverse || _load_babelTraverse()).default)(fileNode, {
      enter: path => {
        const visitor = Visitors[path.node.type];
        if (visitor != null) {
          visitor(path, state, this._matchers);
        }
      } });


    const snapshotPath = (_jestSnapshot || _load_jestSnapshot()).utils.getSnapshotPath(filePath);
    const snapshots = (_jestSnapshot || _load_jestSnapshot()).utils.getSnapshotData(snapshotPath, 'none').data;
    let lastParent = null;
    let count = 1;

    return state.found.map((snapshotNode, index) => {
      const parents = snapshotNode.parents.filter(isValidParent);
      const innerAssertion = parents[parents.length - 1];

      if (lastParent !== innerAssertion) {
        lastParent = innerAssertion;
        count = 1;
      }

      const result = {
        content: undefined,
        count: count++,
        exists: false,
        name: '',
        node: snapshotNode.node };


      if (!innerAssertion || isDescribe(innerAssertion.callee)) {
        // An expectation inside describe never gets executed.
        return result;
      }

      result.name = buildName(snapshotNode, parents, result.count);

      if (snapshots[result.name]) {
        result.exists = true;
        result.content = snapshots[result.name];
      }
      return result;
    });
  }}exports.default = Snapshot;