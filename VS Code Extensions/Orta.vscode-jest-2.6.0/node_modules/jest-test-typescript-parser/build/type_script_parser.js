'use strict';Object.defineProperty(exports, "__esModule", { value: true });exports.













parse = parse;var _fs;function _load_fs() {return _fs = require('fs');}var _typescript;function _load_typescript() {return _typescript = _interopRequireDefault(require('typescript'));}var _jestEditorSupport;function _load_jestEditorSupport() {return _jestEditorSupport = require('jest-editor-support');}function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };}function parse(file) {
  const sourceFile = (_typescript || _load_typescript()).default.createSourceFile(
  file,
  (0, (_fs || _load_fs()).readFileSync)(file).toString(),
  (_typescript || _load_typescript()).default.ScriptTarget.ES3);


  const itBlocks = [];
  const expects = [];
  function searchNodes(node) {
    if (node.kind === (_typescript || _load_typescript()).default.SyntaxKind.CallExpression) {let
      text = node.expression.text;
      if (!text) {
        // Property access (it.only)
        text = node.expression.expression.text;
      }
      if (text === 'it' || text === 'test' || text === 'fit') {
        const position = getNode(sourceFile, node, new (_jestEditorSupport || _load_jestEditorSupport()).ItBlock());
        position.name = node.arguments[0].text;
        itBlocks.push(position);
      } else {
        let element = node.expression;
        let expectText = '';
        while (element && !expectText) {
          expectText = element.text;
          element = element.expression;
        }
        if (expectText === 'expect') {
          const position = getNode(sourceFile, node, new (_jestEditorSupport || _load_jestEditorSupport()).Expect());
          if (
          !expects.some(
          e =>
          e.start.line === position.start.line &&
          e.start.column === position.start.column))

          {
            expects.push(position);
          }
        }
      }
    }
    (_typescript || _load_typescript()).default.forEachChild(node, searchNodes);
  }

  (_typescript || _load_typescript()).default.forEachChild(sourceFile, searchNodes);
  return {
    expects,
    itBlocks };

} /**
   * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */function getNode(file, expression, node) {const start = file.getLineAndCharacterOfPosition(expression.getStart(file));
  // TypeScript parser is 0 based, so we have to increment by 1 to normalize
  node.start = {
    column: start.character + 1,
    line: start.line + 1 };

  const end = file.getLineAndCharacterOfPosition(expression.getEnd());
  node.end = {
    column: end.character + 1,
    line: end.line + 1 };

  node.file = file.fileName;
  return node;
}